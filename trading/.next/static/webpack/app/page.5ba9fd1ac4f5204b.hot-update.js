"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/tradingService.ts":
/*!****************************************!*\
  !*** ./src/services/tradingService.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TradingService: () => (/* binding */ TradingService)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-cache */ \"(app-pages-browser)/./node_modules/node-cache/index.js\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solanaTrackerService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./solanaTrackerService */ \"(app-pages-browser)/./src/services/solanaTrackerService.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nclass TradingService {\n    async findTradingOpportunities() {\n        const opportunities = [];\n        try {\n            // Get trending meme tokens\n            const memeTokens = await this.solanaTracker.findMemeTokens();\n            // Analyze each token\n            for (const token of memeTokens){\n                const tokenInfo = await this.solanaTracker.getTokenInfo(token.mint);\n                const analysis = await this.analyzeToken(tokenInfo);\n                if (!analysis.isRisky) {\n                    var _pool_price, _pool_marketCap, _pool_liquidity, _tokenInfo_events_24h;\n                    const pool = tokenInfo.pools[0];\n                    opportunities.push({\n                        token: {\n                            address: token.mint,\n                            name: token.name,\n                            symbol: token.symbol,\n                            price: (pool === null || pool === void 0 ? void 0 : (_pool_price = pool.price) === null || _pool_price === void 0 ? void 0 : _pool_price.usd) || 0,\n                            marketCap: (pool === null || pool === void 0 ? void 0 : (_pool_marketCap = pool.marketCap) === null || _pool_marketCap === void 0 ? void 0 : _pool_marketCap.usd) || 0,\n                            liquidity: (pool === null || pool === void 0 ? void 0 : (_pool_liquidity = pool.liquidity) === null || _pool_liquidity === void 0 ? void 0 : _pool_liquidity.usd) || 0,\n                            volume24h: 0,\n                            priceChange24h: ((_tokenInfo_events_24h = tokenInfo.events['24h']) === null || _tokenInfo_events_24h === void 0 ? void 0 : _tokenInfo_events_24h.priceChangePercentage) || 0\n                        },\n                        confidence: analysis.confidence,\n                        signals: analysis.signals,\n                        riskLevel: analysis.riskLevel,\n                        timestamp: Date.now()\n                    });\n                }\n            }\n            // Sort opportunities by confidence\n            return opportunities.sort((a, b)=>b.confidence - a.confidence);\n        } catch (error) {\n            console.error('Error finding trading opportunities:', error);\n            return [];\n        }\n    }\n    async analyzeToken(tokenInfo) {\n        var _pool_liquidity, _tokenInfo_events_24h, _holders_accounts_;\n        const signals = [];\n        let confidenceScore = 0;\n        let isRisky = false;\n        // Check token age\n        const pool = tokenInfo.pools[0];\n        if (!pool) {\n            return {\n                isRisky: true,\n                confidence: 0,\n                signals: [\n                    'No liquidity pool found'\n                ],\n                riskLevel: 'HIGH'\n            };\n        }\n        // Analyze liquidity\n        const liquidityUSD = ((_pool_liquidity = pool.liquidity) === null || _pool_liquidity === void 0 ? void 0 : _pool_liquidity.usd) || 0;\n        if (liquidityUSD < 10000) {\n            signals.push('Low liquidity');\n            confidenceScore -= 20;\n        } else if (liquidityUSD > 100000) {\n            signals.push('Strong liquidity');\n            confidenceScore += 20;\n        }\n        // Check LP token burn\n        if (pool.lpBurn === 100) {\n            signals.push('100% LP tokens burned');\n            confidenceScore += 15;\n        } else if (pool.lpBurn < 50) {\n            signals.push('Low LP token burn');\n            confidenceScore -= 15;\n        }\n        // Analyze price movement\n        const priceChange24h = ((_tokenInfo_events_24h = tokenInfo.events['24h']) === null || _tokenInfo_events_24h === void 0 ? void 0 : _tokenInfo_events_24h.priceChangePercentage) || 0;\n        if (Math.abs(priceChange24h) > 50) {\n            signals.push('High volatility');\n            confidenceScore -= 10;\n        } else if (priceChange24h > 10) {\n            signals.push('Positive momentum');\n            confidenceScore += 10;\n        }\n        // Check holder distribution\n        const holders = await this.solanaTracker.getTokenHolders(tokenInfo.token.mint);\n        const topHolderPercentage = ((_holders_accounts_ = holders.accounts[0]) === null || _holders_accounts_ === void 0 ? void 0 : _holders_accounts_.percentage) || 0;\n        if (topHolderPercentage > 50) {\n            signals.push('Concentrated holdings');\n            confidenceScore -= 25;\n            isRisky = true;\n        } else if (topHolderPercentage < 10) {\n            signals.push('Well-distributed holdings');\n            confidenceScore += 15;\n        }\n        // Check security risks\n        if (tokenInfo.risk.rugged) {\n            signals.push('Rug pull risk detected');\n            isRisky = true;\n        }\n        if (tokenInfo.risk.score > 5) {\n            signals.push('High risk score');\n            isRisky = true;\n        }\n        // Determine risk level\n        let riskLevel;\n        if (isRisky || confidenceScore < 0) {\n            riskLevel = 'HIGH';\n        } else if (confidenceScore > 50) {\n            riskLevel = 'LOW';\n        } else {\n            riskLevel = 'MEDIUM';\n        }\n        // Normalize confidence score between 0 and 100\n        confidenceScore = Math.max(0, Math.min(100, confidenceScore + 50));\n        return {\n            isRisky,\n            confidence: confidenceScore,\n            signals,\n            riskLevel\n        };\n    }\n    async monitorToken(tokenAddress) {\n        const cacheKey = \"monitor_\".concat(tokenAddress);\n        if (this.cache.has(cacheKey)) {\n            return this.cache.get(cacheKey);\n        }\n        try {\n            const tokenInfo = await this.solanaTracker.getTokenInfo(tokenAddress);\n            const analysis = await this.analyzeToken(tokenInfo);\n            const monitoringData = {\n                ...tokenInfo,\n                analysis,\n                lastUpdated: Date.now()\n            };\n            this.cache.set(cacheKey, monitoringData);\n            return monitoringData;\n        } catch (error) {\n            console.error('Error monitoring token:', error);\n            throw error;\n        }\n    }\n    async getTokenMetrics(tokenAddress) {\n        try {\n            const [tokenInfo, holders, ath] = await Promise.all([\n                this.solanaTracker.getTokenInfo(tokenAddress),\n                this.solanaTracker.getTokenHolders(tokenAddress),\n                this.solanaTracker.getTokenATH(tokenAddress)\n            ]);\n            return {\n                tokenInfo,\n                holders,\n                ath,\n                lastUpdated: Date.now()\n            };\n        } catch (error) {\n            console.error('Error fetching token metrics:', error);\n            throw error;\n        }\n    }\n    constructor(){\n        var _process_env_RPC_URL;\n        this.solanaTracker = new _solanaTrackerService__WEBPACK_IMPORTED_MODULE_2__.SolanaTrackerService();\n        this.cache = new (node_cache__WEBPACK_IMPORTED_MODULE_1___default())({\n            stdTTL: 300\n        }); // 5 minutes cache\n        const rpcUrl = (((_process_env_RPC_URL = process.env.RPC_URL) === null || _process_env_RPC_URL === void 0 ? void 0 : _process_env_RPC_URL.trim()) || 'https://spl_governance:fraud@crankyskull.com:8899').replace(/\\/$/, '');\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(rpcUrl);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90cmFkaW5nU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0Q7QUFDckI7QUFDb0Q7QUFpQ2hGLE1BQU1HO0lBWVQsTUFBTUMsMkJBQTBEO1FBQzVELE1BQU1DLGdCQUFzQyxFQUFFO1FBRTlDLElBQUk7WUFDQSwyQkFBMkI7WUFDM0IsTUFBTUMsYUFBYSxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxjQUFjO1lBRTFELHFCQUFxQjtZQUNyQixLQUFLLE1BQU1DLFNBQVNILFdBQVk7Z0JBQzVCLE1BQU1JLFlBQVksTUFBTSxJQUFJLENBQUNILGFBQWEsQ0FBQ0ksWUFBWSxDQUFDRixNQUFNRyxJQUFJO2dCQUNsRSxNQUFNQyxXQUFXLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUNKO2dCQUV6QyxJQUFJLENBQUNHLFNBQVNFLE9BQU8sRUFBRTt3QkFPSkMsYUFDSUEsaUJBQ0FBLGlCQUVLTjtvQkFWeEIsTUFBTU0sT0FBT04sVUFBVU8sS0FBSyxDQUFDLEVBQUU7b0JBQy9CWixjQUFjYSxJQUFJLENBQUM7d0JBQ2ZULE9BQU87NEJBQ0hVLFNBQVNWLE1BQU1HLElBQUk7NEJBQ25CUSxNQUFNWCxNQUFNVyxJQUFJOzRCQUNoQkMsUUFBUVosTUFBTVksTUFBTTs0QkFDcEJDLE9BQU9OLENBQUFBLGlCQUFBQSw0QkFBQUEsY0FBQUEsS0FBTU0sS0FBSyxjQUFYTixrQ0FBQUEsWUFBYU8sR0FBRyxLQUFJOzRCQUMzQkMsV0FBV1IsQ0FBQUEsaUJBQUFBLDRCQUFBQSxrQkFBQUEsS0FBTVEsU0FBUyxjQUFmUixzQ0FBQUEsZ0JBQWlCTyxHQUFHLEtBQUk7NEJBQ25DRSxXQUFXVCxDQUFBQSxpQkFBQUEsNEJBQUFBLGtCQUFBQSxLQUFNUyxTQUFTLGNBQWZULHNDQUFBQSxnQkFBaUJPLEdBQUcsS0FBSTs0QkFDbkNHLFdBQVc7NEJBQ1hDLGdCQUFnQmpCLEVBQUFBLHdCQUFBQSxVQUFVa0Is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SUFBSSxDQUFDbEQsYUFBYSxDQUFDOEQsV0FBVyxDQUFDWjthQUNsQztZQUVELE9BQU87Z0JBQ0gvQztnQkFDQStCO2dCQUNBeUI7Z0JBQ0FILGFBQWE3QixLQUFLQyxHQUFHO1lBQ3pCO1FBQ0osRUFBRSxPQUFPSSxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE1BQU1BO1FBQ1Y7SUFDSjtJQWhMQStCLGFBQWM7WUFHTUM7UUFGaEIsSUFBSSxDQUFDaEUsYUFBYSxHQUFHLElBQUlMLHVFQUFvQkE7UUFDN0MsSUFBSSxDQUFDeUQsS0FBSyxHQUFHLElBQUkxRCxtREFBU0EsQ0FBQztZQUFFdUUsUUFBUTtRQUFJLElBQUksa0JBQWtCO1FBQy9ELE1BQU1DLFNBQVMsQ0FBQ0YsRUFBQUEsdUJBQUFBLE9BQU9BLENBQUNHLEdBQUcsQ0FBQ0MsT0FBTyxjQUFuQkosMkNBQUFBLHFCQUFxQkssSUFBSSxPQUFNLG1EQUFrRCxFQUFHQyxPQUFPLENBQUMsT0FBTztRQUNuSCxJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJOUUsdURBQVVBLENBQUN5RTtJQUNyQztBQTRLSiIsInNvdXJjZXMiOlsiL1VzZXJzLzhiaXQvRGVza3RvcC9lbGl6YS90cmFkaW5nL3NyYy9zZXJ2aWNlcy90cmFkaW5nU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IE5vZGVDYWNoZSBmcm9tICdub2RlLWNhY2hlJztcbmltcG9ydCB7IFNvbGFuYVRyYWNrZXJTZXJ2aWNlLCBUb2tlbkluZm8sIFRva2VuSG9sZGVycyB9IGZyb20gJy4vc29sYW5hVHJhY2tlclNlcnZpY2UnO1xuXG5pbnRlcmZhY2UgVHJhZGluZ09wcG9ydHVuaXR5IHtcbiAgICB0b2tlbjoge1xuICAgICAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgICAgIHByaWNlOiBudW1iZXI7XG4gICAgICAgIG1hcmtldENhcDogbnVtYmVyO1xuICAgICAgICBsaXF1aWRpdHk6IG51bWJlcjtcbiAgICAgICAgdm9sdW1lMjRoOiBudW1iZXI7XG4gICAgICAgIHByaWNlQ2hhbmdlMjRoOiBudW1iZXI7XG4gICAgfTtcbiAgICBjb25maWRlbmNlOiBudW1iZXI7XG4gICAgc2lnbmFsczogc3RyaW5nW107XG4gICAgcmlza0xldmVsOiAnTE9XJyB8ICdNRURJVU0nIHwgJ0hJR0gnO1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5BbmFseXNpcyB7XG4gICAgaXNSaXNreTogYm9vbGVhbjtcbiAgICBjb25maWRlbmNlOiBudW1iZXI7XG4gICAgc2lnbmFsczogc3RyaW5nW107XG4gICAgcmlza0xldmVsOiAnTE9XJyB8ICdNRURJVU0nIHwgJ0hJR0gnO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5NZXRyaWNzIHtcbiAgICB0b2tlbkluZm86IFRva2VuSW5mbztcbiAgICBob2xkZXJzOiBUb2tlbkhvbGRlcnM7XG4gICAgYXRoOiB7IGhpZ2hlc3RfcHJpY2U6IG51bWJlciB9O1xuICAgIGxhc3RVcGRhdGVkOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFkaW5nU2VydmljZSB7XG4gICAgcHJpdmF0ZSBzb2xhbmFUcmFja2VyOiBTb2xhbmFUcmFja2VyU2VydmljZTtcbiAgICBwcml2YXRlIGNhY2hlOiBOb2RlQ2FjaGU7XG4gICAgcHJpdmF0ZSBjb25uZWN0aW9uOiBDb25uZWN0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc29sYW5hVHJhY2tlciA9IG5ldyBTb2xhbmFUcmFja2VyU2VydmljZSgpO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE5vZGVDYWNoZSh7IHN0ZFRUTDogMzAwIH0pOyAvLyA1IG1pbnV0ZXMgY2FjaGVcbiAgICAgICAgY29uc3QgcnBjVXJsID0gKHByb2Nlc3MuZW52LlJQQ19VUkw/LnRyaW0oKSB8fCAnaHR0cHM6Ly9zcGxfZ292ZXJuYW5jZTpmcmF1ZEBjcmFua3lza3VsbC5jb206ODg5OScpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBDb25uZWN0aW9uKHJwY1VybCk7XG4gICAgfVxuXG4gICAgYXN5bmMgZmluZFRyYWRpbmdPcHBvcnR1bml0aWVzKCk6IFByb21pc2U8VHJhZGluZ09wcG9ydHVuaXR5W10+IHtcbiAgICAgICAgY29uc3Qgb3Bwb3J0dW5pdGllczogVHJhZGluZ09wcG9ydHVuaXR5W10gPSBbXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IHRyZW5kaW5nIG1lbWUgdG9rZW5zXG4gICAgICAgICAgICBjb25zdCBtZW1lVG9rZW5zID0gYXdhaXQgdGhpcy5zb2xhbmFUcmFja2VyLmZpbmRNZW1lVG9rZW5zKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFuYWx5emUgZWFjaCB0b2tlblxuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBtZW1lVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JbmZvID0gYXdhaXQgdGhpcy5zb2xhbmFUcmFja2VyLmdldFRva2VuSW5mbyh0b2tlbi5taW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmFseXNpcyA9IGF3YWl0IHRoaXMuYW5hbHl6ZVRva2VuKHRva2VuSW5mbyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWFuYWx5c2lzLmlzUmlza3kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9vbCA9IHRva2VuSW5mby5wb29sc1swXTtcbiAgICAgICAgICAgICAgICAgICAgb3Bwb3J0dW5pdGllcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdG9rZW4ubWludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b2tlbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogdG9rZW4uc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBwb29sPy5wcmljZT8udXNkIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya2V0Q2FwOiBwb29sPy5tYXJrZXRDYXA/LnVzZCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpcXVpZGl0eTogcG9vbD8ubGlxdWlkaXR5Py51c2QgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2x1bWUyNGg6IDAsIC8vIE5lZWQgdG8gY2FsY3VsYXRlIGZyb20gdHJhZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2VDaGFuZ2UyNGg6IHRva2VuSW5mby5ldmVudHNbJzI0aCddPy5wcmljZUNoYW5nZVBlcmNlbnRhZ2UgfHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZGVuY2U6IGFuYWx5c2lzLmNvbmZpZGVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWxzOiBhbmFseXNpcy5zaWduYWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlza0xldmVsOiBhbmFseXNpcy5yaXNrTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb3J0IG9wcG9ydHVuaXRpZXMgYnkgY29uZmlkZW5jZVxuICAgICAgICAgICAgcmV0dXJuIG9wcG9ydHVuaXRpZXMuc29ydCgoYSwgYikgPT4gYi5jb25maWRlbmNlIC0gYS5jb25maWRlbmNlKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmluZGluZyB0cmFkaW5nIG9wcG9ydHVuaXRpZXM6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBhbmFseXplVG9rZW4odG9rZW5JbmZvOiBUb2tlbkluZm8pOiBQcm9taXNlPFRva2VuQW5hbHlzaXM+IHtcbiAgICAgICAgY29uc3Qgc2lnbmFsczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgbGV0IGNvbmZpZGVuY2VTY29yZSA9IDA7XG4gICAgICAgIGxldCBpc1Jpc2t5ID0gZmFsc2U7XG5cbiAgICAgICAgLy8gQ2hlY2sgdG9rZW4gYWdlXG4gICAgICAgIGNvbnN0IHBvb2wgPSB0b2tlbkluZm8ucG9vbHNbMF07XG4gICAgICAgIGlmICghcG9vbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNSaXNreTogdHJ1ZSwgY29uZmlkZW5jZTogMCwgc2lnbmFsczogWydObyBsaXF1aWRpdHkgcG9vbCBmb3VuZCddLCByaXNrTGV2ZWw6ICdISUdIJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5hbHl6ZSBsaXF1aWRpdHlcbiAgICAgICAgY29uc3QgbGlxdWlkaXR5VVNEID0gcG9vbC5saXF1aWRpdHk/LnVzZCB8fCAwO1xuICAgICAgICBpZiAobGlxdWlkaXR5VVNEIDwgMTAwMDApIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnTG93IGxpcXVpZGl0eScpO1xuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlIC09IDIwO1xuICAgICAgICB9IGVsc2UgaWYgKGxpcXVpZGl0eVVTRCA+IDEwMDAwMCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdTdHJvbmcgbGlxdWlkaXR5Jyk7XG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmUgKz0gMjA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBMUCB0b2tlbiBidXJuXG4gICAgICAgIGlmIChwb29sLmxwQnVybiA9PT0gMTAwKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJzEwMCUgTFAgdG9rZW5zIGJ1cm5lZCcpO1xuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlICs9IDE1O1xuICAgICAgICB9IGVsc2UgaWYgKHBvb2wubHBCdXJuIDwgNTApIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnTG93IExQIHRva2VuIGJ1cm4nKTtcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZSAtPSAxNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuYWx5emUgcHJpY2UgbW92ZW1lbnRcbiAgICAgICAgY29uc3QgcHJpY2VDaGFuZ2UyNGggPSB0b2tlbkluZm8uZXZlbnRzWycyNGgnXT8ucHJpY2VDaGFuZ2VQZXJjZW50YWdlIHx8IDA7XG4gICAgICAgIGlmIChNYXRoLmFicyhwcmljZUNoYW5nZTI0aCkgPiA1MCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdIaWdoIHZvbGF0aWxpdHknKTtcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZSAtPSAxMDtcbiAgICAgICAgfSBlbHNlIGlmIChwcmljZUNoYW5nZTI0aCA+IDEwKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ1Bvc2l0aXZlIG1vbWVudHVtJyk7XG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmUgKz0gMTA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBob2xkZXIgZGlzdHJpYnV0aW9uXG4gICAgICAgIGNvbnN0IGhvbGRlcnMgPSBhd2FpdCB0aGlzLnNvbGFuYVRyYWNrZXIuZ2V0VG9rZW5Ib2xkZXJzKHRva2VuSW5mby50b2tlbi5taW50KTtcbiAgICAgICAgY29uc3QgdG9wSG9sZGVyUGVyY2VudGFnZSA9IGhvbGRlcnMuYWNjb3VudHNbMF0/LnBlcmNlbnRhZ2UgfHwgMDtcbiAgICAgICAgXG4gICAgICAgIGlmICh0b3BIb2xkZXJQZXJjZW50YWdlID4gNTApIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnQ29uY2VudHJhdGVkIGhvbGRpbmdzJyk7XG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmUgLT0gMjU7XG4gICAgICAgICAgICBpc1Jpc2t5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BIb2xkZXJQZXJjZW50YWdlIDwgMTApIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnV2VsbC1kaXN0cmlidXRlZCBob2xkaW5ncycpO1xuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlICs9IDE1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgc2VjdXJpdHkgcmlza3NcbiAgICAgICAgaWYgKHRva2VuSW5mby5yaXNrLnJ1Z2dlZCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdSdWcgcHVsbCByaXNrIGRldGVjdGVkJyk7XG4gICAgICAgICAgICBpc1Jpc2t5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbkluZm8ucmlzay5zY29yZSA+IDUpIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnSGlnaCByaXNrIHNjb3JlJyk7XG4gICAgICAgICAgICBpc1Jpc2t5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSByaXNrIGxldmVsXG4gICAgICAgIGxldCByaXNrTGV2ZWw6ICdMT1cnIHwgJ01FRElVTScgfCAnSElHSCc7XG4gICAgICAgIGlmIChpc1Jpc2t5IHx8IGNvbmZpZGVuY2VTY29yZSA8IDApIHtcbiAgICAgICAgICAgIHJpc2tMZXZlbCA9ICdISUdIJztcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWRlbmNlU2NvcmUgPiA1MCkge1xuICAgICAgICAgICAgcmlza0xldmVsID0gJ0xPVyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByaXNrTGV2ZWwgPSAnTUVESVVNJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBjb25maWRlbmNlIHNjb3JlIGJldHdlZW4gMCBhbmQgMTAwXG4gICAgICAgIGNvbmZpZGVuY2VTY29yZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgY29uZmlkZW5jZVNjb3JlICsgNTApKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNSaXNreSxcbiAgICAgICAgICAgIGNvbmZpZGVuY2U6IGNvbmZpZGVuY2VTY29yZSxcbiAgICAgICAgICAgIHNpZ25hbHMsXG4gICAgICAgICAgICByaXNrTGV2ZWxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhc3luYyBtb25pdG9yVG9rZW4odG9rZW5BZGRyZXNzOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgbW9uaXRvcl8ke3Rva2VuQWRkcmVzc31gO1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuSW5mbyA9IGF3YWl0IHRoaXMuc29sYW5hVHJhY2tlci5nZXRUb2tlbkluZm8odG9rZW5BZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGFuYWx5c2lzID0gYXdhaXQgdGhpcy5hbmFseXplVG9rZW4odG9rZW5JbmZvKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgbW9uaXRvcmluZ0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgLi4udG9rZW5JbmZvLFxuICAgICAgICAgICAgICAgIGFuYWx5c2lzLFxuICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmNhY2hlLnNldChjYWNoZUtleSwgbW9uaXRvcmluZ0RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIG1vbml0b3JpbmdEYXRhO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbW9uaXRvcmluZyB0b2tlbjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGdldFRva2VuTWV0cmljcyh0b2tlbkFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8VG9rZW5NZXRyaWNzPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBbdG9rZW5JbmZvLCBob2xkZXJzLCBhdGhdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuc29sYW5hVHJhY2tlci5nZXRUb2tlbkluZm8odG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNvbGFuYVRyYWNrZXIuZ2V0VG9rZW5Ib2xkZXJzKHRva2VuQWRkcmVzcyksXG4gICAgICAgICAgICAgICAgdGhpcy5zb2xhbmFUcmFja2VyLmdldFRva2VuQVRIKHRva2VuQWRkcmVzcylcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRva2VuSW5mbyxcbiAgICAgICAgICAgICAgICBob2xkZXJzLFxuICAgICAgICAgICAgICAgIGF0aCxcbiAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRva2VuIG1ldHJpY3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOlsiQ29ubmVjdGlvbiIsIk5vZGVDYWNoZSIsIlNvbGFuYVRyYWNrZXJTZXJ2aWNlIiwiVHJhZGluZ1NlcnZpY2UiLCJmaW5kVHJhZGluZ09wcG9ydHVuaXRpZXMiLCJvcHBvcnR1bml0aWVzIiwibWVtZVRva2VucyIsInNvbGFuYVRyYWNrZXIiLCJmaW5kTWVtZVRva2VucyIsInRva2VuIiwidG9rZW5JbmZvIiwiZ2V0VG9rZW5JbmZvIiwibWludCIsImFuYWx5c2lzIiwiYW5hbHl6ZVRva2VuIiwiaXNSaXNreSIsInBvb2wiLCJwb29scyIsInB1c2giLCJhZGRyZXNzIiwibmFtZSIsInN5bWJvbCIsInByaWNlIiwidXNkIiwibWFya2V0Q2FwIiwibGlxdWlkaXR5Iiwidm9sdW1lMjRoIiwicHJpY2VDaGFuZ2UyNGgiLCJldmVudHMiLCJwcmljZUNoYW5nZVBlcmNlbnRhZ2UiLCJjb25maWRlbmNlIiwic2lnbmFscyIsInJpc2tMZXZlbCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJzb3J0IiwiYSIsImIiLCJlcnJvciIsImNvbnNvbGUiLCJob2xkZXJzIiwiY29uZmlkZW5jZVNjb3JlIiwibGlxdWlkaXR5VVNEIiwibHBCdXJuIiwiTWF0aCIsImFicyIsImdldFRva2VuSG9sZGVycyIsInRvcEhvbGRlclBlcmNlbnRhZ2UiLCJhY2NvdW50cyIsInBlcmNlbnRhZ2UiLCJyaXNrIiwicnVnZ2VkIiwic2NvcmUiLCJtYXgiLCJtaW4iLCJtb25pdG9yVG9rZW4iLCJ0b2tlbkFkZHJlc3MiLCJjYWNoZUtleSIsImNhY2hlIiwiaGFzIiwiZ2V0IiwibW9uaXRvcmluZ0RhdGEiLCJsYXN0VXBkYXRlZCIsInNldCIsImdldFRva2VuTWV0cmljcyIsImF0aCIsIlByb21pc2UiLCJhbGwiLCJnZXRUb2tlbkFUSCIsImNvbnN0cnVjdG9yIiwicHJvY2VzcyIsInN0ZFRUTCIsInJwY1VybCIsImVudiIsIlJQQ19VUkwiLCJ0cmltIiwicmVwbGFjZSIsImNvbm5lY3Rpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/tradingService.ts\n"));

/***/ })

});