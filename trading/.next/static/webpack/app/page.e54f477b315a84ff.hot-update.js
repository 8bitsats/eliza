"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/tradingService.ts":
/*!****************************************!*\
  !*** ./src/services/tradingService.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TradingService: () => (/* binding */ TradingService)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-cache */ \"(app-pages-browser)/./node_modules/node-cache/index.js\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solanaTrackerService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./solanaTrackerService */ \"(app-pages-browser)/./src/services/solanaTrackerService.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nclass TradingService {\n    async findTradingOpportunities() {\n        const opportunities = [];\n        try {\n            // Get trending meme tokens\n            const memeTokens = await this.solanaTracker.findMemeTokens();\n            // Analyze each token\n            for (const token of memeTokens){\n                const tokenInfo = await this.solanaTracker.getTokenInfo(token.mint);\n                const analysis = await this.analyzeToken(tokenInfo);\n                if (!analysis.isRisky) {\n                    var _pool_price, _pool_marketCap, _pool_liquidity, _tokenInfo_events_24h;\n                    const pool = tokenInfo.pools[0];\n                    opportunities.push({\n                        token: {\n                            address: token.mint,\n                            name: token.name,\n                            symbol: token.symbol,\n                            price: (pool === null || pool === void 0 ? void 0 : (_pool_price = pool.price) === null || _pool_price === void 0 ? void 0 : _pool_price.usd) || 0,\n                            marketCap: (pool === null || pool === void 0 ? void 0 : (_pool_marketCap = pool.marketCap) === null || _pool_marketCap === void 0 ? void 0 : _pool_marketCap.usd) || 0,\n                            liquidity: (pool === null || pool === void 0 ? void 0 : (_pool_liquidity = pool.liquidity) === null || _pool_liquidity === void 0 ? void 0 : _pool_liquidity.usd) || 0,\n                            volume24h: 0,\n                            priceChange24h: ((_tokenInfo_events_24h = tokenInfo.events['24h']) === null || _tokenInfo_events_24h === void 0 ? void 0 : _tokenInfo_events_24h.priceChangePercentage) || 0\n                        },\n                        confidence: analysis.confidence,\n                        signals: analysis.signals,\n                        riskLevel: analysis.riskLevel,\n                        timestamp: Date.now()\n                    });\n                }\n            }\n            // Sort opportunities by confidence\n            return opportunities.sort((a, b)=>b.confidence - a.confidence);\n        } catch (error) {\n            console.error('Error finding trading opportunities:', error);\n            return [];\n        }\n    }\n    async analyzeToken(tokenInfo) {\n        var _pool_liquidity, _tokenInfo_events_24h, _holders_accounts_;\n        const signals = [];\n        let confidenceScore = 0;\n        let isRisky = false;\n        // Check token age\n        const pool = tokenInfo.pools[0];\n        if (!pool) {\n            return {\n                isRisky: true,\n                confidence: 0,\n                signals: [\n                    'No liquidity pool found'\n                ],\n                riskLevel: 'HIGH'\n            };\n        }\n        // Analyze liquidity\n        const liquidityUSD = ((_pool_liquidity = pool.liquidity) === null || _pool_liquidity === void 0 ? void 0 : _pool_liquidity.usd) || 0;\n        if (liquidityUSD < 10000) {\n            signals.push('Low liquidity');\n            confidenceScore -= 20;\n        } else if (liquidityUSD > 100000) {\n            signals.push('Strong liquidity');\n            confidenceScore += 20;\n        }\n        // Check LP token burn\n        if (pool.lpBurn === 100) {\n            signals.push('100% LP tokens burned');\n            confidenceScore += 15;\n        } else if (pool.lpBurn < 50) {\n            signals.push('Low LP token burn');\n            confidenceScore -= 15;\n        }\n        // Analyze price movement\n        const priceChange24h = ((_tokenInfo_events_24h = tokenInfo.events['24h']) === null || _tokenInfo_events_24h === void 0 ? void 0 : _tokenInfo_events_24h.priceChangePercentage) || 0;\n        if (Math.abs(priceChange24h) > 50) {\n            signals.push('High volatility');\n            confidenceScore -= 10;\n        } else if (priceChange24h > 10) {\n            signals.push('Positive momentum');\n            confidenceScore += 10;\n        }\n        // Check holder distribution\n        const holders = await this.solanaTracker.getTokenHolders(tokenInfo.token.mint);\n        const topHolderPercentage = ((_holders_accounts_ = holders.accounts[0]) === null || _holders_accounts_ === void 0 ? void 0 : _holders_accounts_.percentage) || 0;\n        if (topHolderPercentage > 50) {\n            signals.push('Concentrated holdings');\n            confidenceScore -= 25;\n            isRisky = true;\n        } else if (topHolderPercentage < 10) {\n            signals.push('Well-distributed holdings');\n            confidenceScore += 15;\n        }\n        // Check security risks\n        if (tokenInfo.risk.rugged) {\n            signals.push('Rug pull risk detected');\n            isRisky = true;\n        }\n        if (tokenInfo.risk.score > 5) {\n            signals.push('High risk score');\n            isRisky = true;\n        }\n        // Determine risk level\n        let riskLevel;\n        if (isRisky || confidenceScore < 0) {\n            riskLevel = 'HIGH';\n        } else if (confidenceScore > 50) {\n            riskLevel = 'LOW';\n        } else {\n            riskLevel = 'MEDIUM';\n        }\n        // Normalize confidence score between 0 and 100\n        confidenceScore = Math.max(0, Math.min(100, confidenceScore + 50));\n        return {\n            isRisky,\n            confidence: confidenceScore,\n            signals,\n            riskLevel\n        };\n    }\n    async monitorToken(tokenAddress) {\n        const cacheKey = \"monitor_\".concat(tokenAddress);\n        if (this.cache.has(cacheKey)) {\n            return this.cache.get(cacheKey);\n        }\n        try {\n            const tokenInfo = await this.solanaTracker.getTokenInfo(tokenAddress);\n            const analysis = await this.analyzeToken(tokenInfo);\n            const monitoringData = {\n                ...tokenInfo,\n                analysis,\n                lastUpdated: Date.now()\n            };\n            this.cache.set(cacheKey, monitoringData);\n            return monitoringData;\n        } catch (error) {\n            console.error('Error monitoring token:', error);\n            throw error;\n        }\n    }\n    async getTokenMetrics(tokenAddress) {\n        try {\n            const [tokenInfo, holders, ath] = await Promise.all([\n                this.solanaTracker.getTokenInfo(tokenAddress),\n                this.solanaTracker.getTokenHolders(tokenAddress),\n                this.solanaTracker.getTokenATH(tokenAddress)\n            ]);\n            return {\n                tokenInfo,\n                holders,\n                ath,\n                lastUpdated: Date.now()\n            };\n        } catch (error) {\n            console.error('Error fetching token metrics:', error);\n            throw error;\n        }\n    }\n    constructor(){\n        var _process_env_RPC_URL;\n        this.solanaTracker = new _solanaTrackerService__WEBPACK_IMPORTED_MODULE_2__.SolanaTrackerService();\n        this.cache = new (node_cache__WEBPACK_IMPORTED_MODULE_1___default())({\n            stdTTL: 300\n        }); // 5 minutes cache\n        const rpcUrl = ((_process_env_RPC_URL = process.env.RPC_URL) === null || _process_env_RPC_URL === void 0 ? void 0 : _process_env_RPC_URL.trim()) || 'https://spl_governance:fracTiv87tSS87SsKuT3ZgZFMN4uL98YcW3uWzhe6qU8@api.mainnet-beta.solana.com';\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(rpcUrl);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90cmFkaW5nU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0Q7QUFDckI7QUFDb0Q7QUFpQ2hGLE1BQU1HO0lBWVQsTUFBTUMsMkJBQTBEO1FBQzVELE1BQU1DLGdCQUFzQyxFQUFFO1FBRTlDLElBQUk7WUFDQSwyQkFBMkI7WUFDM0IsTUFBTUMsYUFBYSxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxjQUFjO1lBRTFELHFCQUFxQjtZQUNyQixLQUFLLE1BQU1DLFNBQVNILFdBQVk7Z0JBQzVCLE1BQU1JLFlBQVksTUFBTSxJQUFJLENBQUNILGFBQWEsQ0FBQ0ksWUFBWSxDQUFDRixNQUFNRyxJQUFJO2dCQUNsRSxNQUFNQyxXQUFXLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUNKO2dCQUV6QyxJQUFJLENBQUNHLFNBQVNFLE9BQU8sRUFBRTt3QkFPSkMsYUFDSUEsaUJBQ0FBLGlCQUVLTjtvQkFWeEIsTUFBTU0sT0FBT04sVUFBVU8sS0FBSyxDQUFDLEVBQUU7b0JBQy9CWixjQUFjYSxJQUFJLENBQUM7d0JBQ2ZULE9BQU87NEJBQ0hVLFNBQVNWLE1BQU1HLElBQUk7NEJBQ25CUSxNQUFNWCxNQUFNVyxJQUFJOzRCQUNoQkMsUUFBUVosTUFBTVksTUFBTTs0QkFDcEJDLE9BQU9OLENBQUFBLGlCQUFBQSw0QkFBQUEsY0FBQUEsS0FBTU0sS0FBSyxjQUFYTixrQ0FBQUEsWUFBYU8sR0FBRyxLQUFJOzRCQUMzQkMsV0FBV1IsQ0FBQUEsaUJBQUFBLDRCQUFBQSxrQkFBQUEsS0FBTVEsU0FBUyxjQUFmUixzQ0FBQUEsZ0JBQWlCTyxHQUFHLEtBQUk7NEJBQ25DRSxXQUFXVCxDQUFBQSxpQkFBQUEsNEJBQUFBLGtCQUFBQSxLQUFNUyxTQUFTLGNBQWZULHNDQUFBQSxnQkFBaUJPLEdBQUcsS0FBSTs0QkFDbkNHLFdBQVc7NEJBQ1hDLGdCQUFnQmpCLEVBQUFBLHdCQUFBQSxVQUFVa0Is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SUFBSSxDQUFDbEQsYUFBYSxDQUFDOEQsV0FBVyxDQUFDWjthQUNsQztZQUVELE9BQU87Z0JBQ0gvQztnQkFDQStCO2dCQUNBeUI7Z0JBQ0FILGFBQWE3QixLQUFLQyxHQUFHO1lBQ3pCO1FBQ0osRUFBRSxPQUFPSSxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE1BQU1BO1FBQ1Y7SUFDSjtJQWhMQStCLGFBQWM7WUFHS0M7UUFGZixJQUFJLENBQUNoRSxhQUFhLEdBQUcsSUFBSUwsdUVBQW9CQTtRQUM3QyxJQUFJLENBQUN5RCxLQUFLLEdBQUcsSUFBSTFELG1EQUFTQSxDQUFDO1lBQUV1RSxRQUFRO1FBQUksSUFBSSxrQkFBa0I7UUFDL0QsTUFBTUMsU0FBU0YsRUFBQUEsdUJBQUFBLE9BQU9BLENBQUNHLEdBQUcsQ0FBQ0MsT0FBTyxjQUFuQkosMkNBQUFBLHFCQUFxQkssSUFBSSxPQUFNO1FBQzlDLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUk3RSx1REFBVUEsQ0FBQ3lFO0lBQ3JDO0FBNEtKIiwic291cmNlcyI6WyIvVXNlcnMvOGJpdC9EZXNrdG9wL2VsaXphL3RyYWRpbmcvc3JjL3NlcnZpY2VzL3RyYWRpbmdTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgTm9kZUNhY2hlIGZyb20gJ25vZGUtY2FjaGUnO1xuaW1wb3J0IHsgU29sYW5hVHJhY2tlclNlcnZpY2UsIFRva2VuSW5mbywgVG9rZW5Ib2xkZXJzIH0gZnJvbSAnLi9zb2xhbmFUcmFja2VyU2VydmljZSc7XG5cbmludGVyZmFjZSBUcmFkaW5nT3Bwb3J0dW5pdHkge1xuICAgIHRva2VuOiB7XG4gICAgICAgIGFkZHJlc3M6IHN0cmluZztcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICBzeW1ib2w6IHN0cmluZztcbiAgICAgICAgcHJpY2U6IG51bWJlcjtcbiAgICAgICAgbWFya2V0Q2FwOiBudW1iZXI7XG4gICAgICAgIGxpcXVpZGl0eTogbnVtYmVyO1xuICAgICAgICB2b2x1bWUyNGg6IG51bWJlcjtcbiAgICAgICAgcHJpY2VDaGFuZ2UyNGg6IG51bWJlcjtcbiAgICB9O1xuICAgIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgICBzaWduYWxzOiBzdHJpbmdbXTtcbiAgICByaXNrTGV2ZWw6ICdMT1cnIHwgJ01FRElVTScgfCAnSElHSCc7XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBUb2tlbkFuYWx5c2lzIHtcbiAgICBpc1Jpc2t5OiBib29sZWFuO1xuICAgIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgICBzaWduYWxzOiBzdHJpbmdbXTtcbiAgICByaXNrTGV2ZWw6ICdMT1cnIHwgJ01FRElVTScgfCAnSElHSCc7XG59XG5cbmludGVyZmFjZSBUb2tlbk1ldHJpY3Mge1xuICAgIHRva2VuSW5mbzogVG9rZW5JbmZvO1xuICAgIGhvbGRlcnM6IFRva2VuSG9sZGVycztcbiAgICBhdGg6IHsgaGlnaGVzdF9wcmljZTogbnVtYmVyIH07XG4gICAgbGFzdFVwZGF0ZWQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFRyYWRpbmdTZXJ2aWNlIHtcbiAgICBwcml2YXRlIHNvbGFuYVRyYWNrZXI6IFNvbGFuYVRyYWNrZXJTZXJ2aWNlO1xuICAgIHByaXZhdGUgY2FjaGU6IE5vZGVDYWNoZTtcbiAgICBwcml2YXRlIGNvbm5lY3Rpb246IENvbm5lY3Rpb247XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zb2xhbmFUcmFja2VyID0gbmV3IFNvbGFuYVRyYWNrZXJTZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTm9kZUNhY2hlKHsgc3RkVFRMOiAzMDAgfSk7IC8vIDUgbWludXRlcyBjYWNoZVxuICAgICAgICBjb25zdCBycGNVcmwgPSBwcm9jZXNzLmVudi5SUENfVVJMPy50cmltKCkgfHwgJ2h0dHBzOi8vc3BsX2dvdmVybmFuY2U6ZnJhY1Rpdjg3dFNTODdTc0t1VDNaZ1pGTU40dUw5OFljVzN1V3poZTZxVThAYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tJztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24ocnBjVXJsKTtcbiAgICB9XG5cbiAgICBhc3luYyBmaW5kVHJhZGluZ09wcG9ydHVuaXRpZXMoKTogUHJvbWlzZTxUcmFkaW5nT3Bwb3J0dW5pdHlbXT4ge1xuICAgICAgICBjb25zdCBvcHBvcnR1bml0aWVzOiBUcmFkaW5nT3Bwb3J0dW5pdHlbXSA9IFtdO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBHZXQgdHJlbmRpbmcgbWVtZSB0b2tlbnNcbiAgICAgICAgICAgIGNvbnN0IG1lbWVUb2tlbnMgPSBhd2FpdCB0aGlzLnNvbGFuYVRyYWNrZXIuZmluZE1lbWVUb2tlbnMoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQW5hbHl6ZSBlYWNoIHRva2VuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIG1lbWVUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkluZm8gPSBhd2FpdCB0aGlzLnNvbGFuYVRyYWNrZXIuZ2V0VG9rZW5JbmZvKHRva2VuLm1pbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuYWx5c2lzID0gYXdhaXQgdGhpcy5hbmFseXplVG9rZW4odG9rZW5JbmZvKTtcblxuICAgICAgICAgICAgICAgIGlmICghYW5hbHlzaXMuaXNSaXNreSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb29sID0gdG9rZW5JbmZvLnBvb2xzWzBdO1xuICAgICAgICAgICAgICAgICAgICBvcHBvcnR1bml0aWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0b2tlbi5taW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRva2VuLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiB0b2tlbi5zeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpY2U6IHBvb2w/LnByaWNlPy51c2QgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXRDYXA6IHBvb2w/Lm1hcmtldENhcD8udXNkIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlxdWlkaXR5OiBwb29sPy5saXF1aWRpdHk/LnVzZCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTI0aDogMCwgLy8gTmVlZCB0byBjYWxjdWxhdGUgZnJvbSB0cmFkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmljZUNoYW5nZTI0aDogdG9rZW5JbmZvLmV2ZW50c1snMjRoJ10/LnByaWNlQ2hhbmdlUGVyY2VudGFnZSB8fCAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlkZW5jZTogYW5hbHlzaXMuY29uZmlkZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbHM6IGFuYWx5c2lzLnNpZ25hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICByaXNrTGV2ZWw6IGFuYWx5c2lzLnJpc2tMZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNvcnQgb3Bwb3J0dW5pdGllcyBieSBjb25maWRlbmNlXG4gICAgICAgICAgICByZXR1cm4gb3Bwb3J0dW5pdGllcy5zb3J0KChhLCBiKSA9PiBiLmNvbmZpZGVuY2UgLSBhLmNvbmZpZGVuY2UpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmaW5kaW5nIHRyYWRpbmcgb3Bwb3J0dW5pdGllczonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIGFuYWx5emVUb2tlbih0b2tlbkluZm86IFRva2VuSW5mbyk6IFByb21pc2U8VG9rZW5BbmFseXNpcz4ge1xuICAgICAgICBjb25zdCBzaWduYWxzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBsZXQgY29uZmlkZW5jZVNjb3JlID0gMDtcbiAgICAgICAgbGV0IGlzUmlza3kgPSBmYWxzZTtcblxuICAgICAgICAvLyBDaGVjayB0b2tlbiBhZ2VcbiAgICAgICAgY29uc3QgcG9vbCA9IHRva2VuSW5mby5wb29sc1swXTtcbiAgICAgICAgaWYgKCFwb29sKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpc1Jpc2t5OiB0cnVlLCBjb25maWRlbmNlOiAwLCBzaWduYWxzOiBbJ05vIGxpcXVpZGl0eSBwb29sIGZvdW5kJ10sIHJpc2tMZXZlbDogJ0hJR0gnIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmFseXplIGxpcXVpZGl0eVxuICAgICAgICBjb25zdCBsaXF1aWRpdHlVU0QgPSBwb29sLmxpcXVpZGl0eT8udXNkIHx8IDA7XG4gICAgICAgIGlmIChsaXF1aWRpdHlVU0QgPCAxMDAwMCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdMb3cgbGlxdWlkaXR5Jyk7XG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmUgLT0gMjA7XG4gICAgICAgIH0gZWxzZSBpZiAobGlxdWlkaXR5VVNEID4gMTAwMDAwKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ1N0cm9uZyBsaXF1aWRpdHknKTtcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZSArPSAyMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIExQIHRva2VuIGJ1cm5cbiAgICAgICAgaWYgKHBvb2wubHBCdXJuID09PSAxMDApIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnMTAwJSBMUCB0b2tlbnMgYnVybmVkJyk7XG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmUgKz0gMTU7XG4gICAgICAgIH0gZWxzZSBpZiAocG9vbC5scEJ1cm4gPCA1MCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdMb3cgTFAgdG9rZW4gYnVybicpO1xuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlIC09IDE1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5hbHl6ZSBwcmljZSBtb3ZlbWVudFxuICAgICAgICBjb25zdCBwcmljZUNoYW5nZTI0aCA9IHRva2VuSW5mby5ldmVudHNbJzI0aCddPy5wcmljZUNoYW5nZVBlcmNlbnRhZ2UgfHwgMDtcbiAgICAgICAgaWYgKE1hdGguYWJzKHByaWNlQ2hhbmdlMjRoKSA+IDUwKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ0hpZ2ggdm9sYXRpbGl0eScpO1xuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlIC09IDEwO1xuICAgICAgICB9IGVsc2UgaWYgKHByaWNlQ2hhbmdlMjRoID4gMTApIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnUG9zaXRpdmUgbW9tZW50dW0nKTtcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZSArPSAxMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGhvbGRlciBkaXN0cmlidXRpb25cbiAgICAgICAgY29uc3QgaG9sZGVycyA9IGF3YWl0IHRoaXMuc29sYW5hVHJhY2tlci5nZXRUb2tlbkhvbGRlcnModG9rZW5JbmZvLnRva2VuLm1pbnQpO1xuICAgICAgICBjb25zdCB0b3BIb2xkZXJQZXJjZW50YWdlID0gaG9sZGVycy5hY2NvdW50c1swXT8ucGVyY2VudGFnZSB8fCAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRvcEhvbGRlclBlcmNlbnRhZ2UgPiA1MCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdDb25jZW50cmF0ZWQgaG9sZGluZ3MnKTtcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZSAtPSAyNTtcbiAgICAgICAgICAgIGlzUmlza3kgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcEhvbGRlclBlcmNlbnRhZ2UgPCAxMCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdXZWxsLWRpc3RyaWJ1dGVkIGhvbGRpbmdzJyk7XG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmUgKz0gMTU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBzZWN1cml0eSByaXNrc1xuICAgICAgICBpZiAodG9rZW5JbmZvLnJpc2sucnVnZ2VkKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ1J1ZyBwdWxsIHJpc2sgZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIGlzUmlza3kgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuSW5mby5yaXNrLnNjb3JlID4gNSkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdIaWdoIHJpc2sgc2NvcmUnKTtcbiAgICAgICAgICAgIGlzUmlza3kgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHJpc2sgbGV2ZWxcbiAgICAgICAgbGV0IHJpc2tMZXZlbDogJ0xPVycgfCAnTUVESVVNJyB8ICdISUdIJztcbiAgICAgICAgaWYgKGlzUmlza3kgfHwgY29uZmlkZW5jZVNjb3JlIDwgMCkge1xuICAgICAgICAgICAgcmlza0xldmVsID0gJ0hJR0gnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZGVuY2VTY29yZSA+IDUwKSB7XG4gICAgICAgICAgICByaXNrTGV2ZWwgPSAnTE9XJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJpc2tMZXZlbCA9ICdNRURJVU0nO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIGNvbmZpZGVuY2Ugc2NvcmUgYmV0d2VlbiAwIGFuZCAxMDBcbiAgICAgICAgY29uZmlkZW5jZVNjb3JlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBjb25maWRlbmNlU2NvcmUgKyA1MCkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1Jpc2t5LFxuICAgICAgICAgICAgY29uZmlkZW5jZTogY29uZmlkZW5jZVNjb3JlLFxuICAgICAgICAgICAgc2lnbmFscyxcbiAgICAgICAgICAgIHJpc2tMZXZlbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIG1vbml0b3JUb2tlbih0b2tlbkFkZHJlc3M6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGBtb25pdG9yXyR7dG9rZW5BZGRyZXNzfWA7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5JbmZvID0gYXdhaXQgdGhpcy5zb2xhbmFUcmFja2VyLmdldFRva2VuSW5mbyh0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCB0aGlzLmFuYWx5emVUb2tlbih0b2tlbkluZm8pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBtb25pdG9yaW5nRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAuLi50b2tlbkluZm8sXG4gICAgICAgICAgICAgICAgYW5hbHlzaXMsXG4gICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCBtb25pdG9yaW5nRGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gbW9uaXRvcmluZ0RhdGE7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBtb25pdG9yaW5nIHRva2VuOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0VG9rZW5NZXRyaWNzKHRva2VuQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxUb2tlbk1ldHJpY3M+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFt0b2tlbkluZm8sIGhvbGRlcnMsIGF0aF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5zb2xhbmFUcmFja2VyLmdldFRva2VuSW5mbyh0b2tlbkFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIHRoaXMuc29sYW5hVHJhY2tlci5nZXRUb2tlbkhvbGRlcnModG9rZW5BZGRyZXNzKSxcbiAgICAgICAgICAgICAgICB0aGlzLnNvbGFuYVRyYWNrZXIuZ2V0VG9rZW5BVEgodG9rZW5BZGRyZXNzKVxuICAgICAgICAgICAgXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9rZW5JbmZvLFxuICAgICAgICAgICAgICAgIGhvbGRlcnMsXG4gICAgICAgICAgICAgICAgYXRoLFxuICAgICAgICAgICAgICAgIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdG9rZW4gbWV0cmljczonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJDb25uZWN0aW9uIiwiTm9kZUNhY2hlIiwiU29sYW5hVHJhY2tlclNlcnZpY2UiLCJUcmFkaW5nU2VydmljZSIsImZpbmRUcmFkaW5nT3Bwb3J0dW5pdGllcyIsIm9wcG9ydHVuaXRpZXMiLCJtZW1lVG9rZW5zIiwic29sYW5hVHJhY2tlciIsImZpbmRNZW1lVG9rZW5zIiwidG9rZW4iLCJ0b2tlbkluZm8iLCJnZXRUb2tlbkluZm8iLCJtaW50IiwiYW5hbHlzaXMiLCJhbmFseXplVG9rZW4iLCJpc1Jpc2t5IiwicG9vbCIsInBvb2xzIiwicHVzaCIsImFkZHJlc3MiLCJuYW1lIiwic3ltYm9sIiwicHJpY2UiLCJ1c2QiLCJtYXJrZXRDYXAiLCJsaXF1aWRpdHkiLCJ2b2x1bWUyNGgiLCJwcmljZUNoYW5nZTI0aCIsImV2ZW50cyIsInByaWNlQ2hhbmdlUGVyY2VudGFnZSIsImNvbmZpZGVuY2UiLCJzaWduYWxzIiwicmlza0xldmVsIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInNvcnQiLCJhIiwiYiIsImVycm9yIiwiY29uc29sZSIsImhvbGRlcnMiLCJjb25maWRlbmNlU2NvcmUiLCJsaXF1aWRpdHlVU0QiLCJscEJ1cm4iLCJNYXRoIiwiYWJzIiwiZ2V0VG9rZW5Ib2xkZXJzIiwidG9wSG9sZGVyUGVyY2VudGFnZSIsImFjY291bnRzIiwicGVyY2VudGFnZSIsInJpc2siLCJydWdnZWQiLCJzY29yZSIsIm1heCIsIm1pbiIsIm1vbml0b3JUb2tlbiIsInRva2VuQWRkcmVzcyIsImNhY2hlS2V5IiwiY2FjaGUiLCJoYXMiLCJnZXQiLCJtb25pdG9yaW5nRGF0YSIsImxhc3RVcGRhdGVkIiwic2V0IiwiZ2V0VG9rZW5NZXRyaWNzIiwiYXRoIiwiUHJvbWlzZSIsImFsbCIsImdldFRva2VuQVRIIiwiY29uc3RydWN0b3IiLCJwcm9jZXNzIiwic3RkVFRMIiwicnBjVXJsIiwiZW52IiwiUlBDX1VSTCIsInRyaW0iLCJjb25uZWN0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/tradingService.ts\n"));

/***/ })

});