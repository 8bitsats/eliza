"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/services/tradingService.ts":
/*!****************************************!*\
  !*** ./src/services/tradingService.ts ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TradingService: () => (/* binding */ TradingService)\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node-cache */ \"(app-pages-browser)/./node_modules/node-cache/index.js\");\n/* harmony import */ var node_cache__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_cache__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solanaTrackerService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./solanaTrackerService */ \"(app-pages-browser)/./src/services/solanaTrackerService.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\nclass TradingService {\n    async findTradingOpportunities() {\n        const opportunities = [];\n        try {\n            // Get trending meme tokens\n            const memeTokens = await this.solanaTracker.findMemeTokens();\n            // Analyze each token\n            for (const token of memeTokens){\n                const tokenInfo = await this.solanaTracker.getTokenInfo(token.mint);\n                const analysis = await this.analyzeToken(tokenInfo);\n                if (!analysis.isRisky) {\n                    var _pool_price, _pool_marketCap, _pool_liquidity, _tokenInfo_events_24h;\n                    const pool = tokenInfo.pools[0];\n                    opportunities.push({\n                        token: {\n                            address: token.mint,\n                            name: token.name,\n                            symbol: token.symbol,\n                            price: (pool === null || pool === void 0 ? void 0 : (_pool_price = pool.price) === null || _pool_price === void 0 ? void 0 : _pool_price.usd) || 0,\n                            marketCap: (pool === null || pool === void 0 ? void 0 : (_pool_marketCap = pool.marketCap) === null || _pool_marketCap === void 0 ? void 0 : _pool_marketCap.usd) || 0,\n                            liquidity: (pool === null || pool === void 0 ? void 0 : (_pool_liquidity = pool.liquidity) === null || _pool_liquidity === void 0 ? void 0 : _pool_liquidity.usd) || 0,\n                            volume24h: 0,\n                            priceChange24h: ((_tokenInfo_events_24h = tokenInfo.events['24h']) === null || _tokenInfo_events_24h === void 0 ? void 0 : _tokenInfo_events_24h.priceChangePercentage) || 0\n                        },\n                        confidence: analysis.confidence,\n                        signals: analysis.signals,\n                        riskLevel: analysis.riskLevel,\n                        timestamp: Date.now()\n                    });\n                }\n            }\n            // Sort opportunities by confidence\n            return opportunities.sort((a, b)=>b.confidence - a.confidence);\n        } catch (error) {\n            console.error('Error finding trading opportunities:', error);\n            return [];\n        }\n    }\n    async analyzeToken(tokenInfo) {\n        var _pool_liquidity, _tokenInfo_events_24h, _holders_accounts_;\n        const signals = [];\n        let confidenceScore = 0;\n        let isRisky = false;\n        // Check token age\n        const pool = tokenInfo.pools[0];\n        if (!pool) {\n            return {\n                isRisky: true,\n                confidence: 0,\n                signals: [\n                    'No liquidity pool found'\n                ],\n                riskLevel: 'HIGH'\n            };\n        }\n        // Analyze liquidity\n        const liquidityUSD = ((_pool_liquidity = pool.liquidity) === null || _pool_liquidity === void 0 ? void 0 : _pool_liquidity.usd) || 0;\n        if (liquidityUSD < 10000) {\n            signals.push('Low liquidity');\n            confidenceScore -= 20;\n        } else if (liquidityUSD > 100000) {\n            signals.push('Strong liquidity');\n            confidenceScore += 20;\n        }\n        // Check LP token burn\n        if (pool.lpBurn === 100) {\n            signals.push('100% LP tokens burned');\n            confidenceScore += 15;\n        } else if (pool.lpBurn < 50) {\n            signals.push('Low LP token burn');\n            confidenceScore -= 15;\n        }\n        // Analyze price movement\n        const priceChange24h = ((_tokenInfo_events_24h = tokenInfo.events['24h']) === null || _tokenInfo_events_24h === void 0 ? void 0 : _tokenInfo_events_24h.priceChangePercentage) || 0;\n        if (Math.abs(priceChange24h) > 50) {\n            signals.push('High volatility');\n            confidenceScore -= 10;\n        } else if (priceChange24h > 10) {\n            signals.push('Positive momentum');\n            confidenceScore += 10;\n        }\n        // Check holder distribution\n        const holders = await this.solanaTracker.getTokenHolders(tokenInfo.token.mint);\n        const topHolderPercentage = ((_holders_accounts_ = holders.accounts[0]) === null || _holders_accounts_ === void 0 ? void 0 : _holders_accounts_.percentage) || 0;\n        if (topHolderPercentage > 50) {\n            signals.push('Concentrated holdings');\n            confidenceScore -= 25;\n            isRisky = true;\n        } else if (topHolderPercentage < 10) {\n            signals.push('Well-distributed holdings');\n            confidenceScore += 15;\n        }\n        // Check security risks\n        if (tokenInfo.risk.rugged) {\n            signals.push('Rug pull risk detected');\n            isRisky = true;\n        }\n        if (tokenInfo.risk.score > 5) {\n            signals.push('High risk score');\n            isRisky = true;\n        }\n        // Determine risk level\n        let riskLevel;\n        if (isRisky || confidenceScore < 0) {\n            riskLevel = 'HIGH';\n        } else if (confidenceScore > 50) {\n            riskLevel = 'LOW';\n        } else {\n            riskLevel = 'MEDIUM';\n        }\n        // Normalize confidence score between 0 and 100\n        confidenceScore = Math.max(0, Math.min(100, confidenceScore + 50));\n        return {\n            isRisky,\n            confidence: confidenceScore,\n            signals,\n            riskLevel\n        };\n    }\n    async monitorToken(tokenAddress) {\n        const cacheKey = \"monitor_\".concat(tokenAddress);\n        if (this.cache.has(cacheKey)) {\n            return this.cache.get(cacheKey);\n        }\n        try {\n            const tokenInfo = await this.solanaTracker.getTokenInfo(tokenAddress);\n            const analysis = await this.analyzeToken(tokenInfo);\n            const monitoringData = {\n                ...tokenInfo,\n                analysis,\n                lastUpdated: Date.now()\n            };\n            this.cache.set(cacheKey, monitoringData);\n            return monitoringData;\n        } catch (error) {\n            console.error('Error monitoring token:', error);\n            throw error;\n        }\n    }\n    async getTokenMetrics(tokenAddress) {\n        try {\n            const [tokenInfo, holders, ath] = await Promise.all([\n                this.solanaTracker.getTokenInfo(tokenAddress),\n                this.solanaTracker.getTokenHolders(tokenAddress),\n                this.solanaTracker.getTokenATH(tokenAddress)\n            ]);\n            return {\n                tokenInfo,\n                holders,\n                ath,\n                lastUpdated: Date.now()\n            };\n        } catch (error) {\n            console.error('Error fetching token metrics:', error);\n            throw error;\n        }\n    }\n    constructor(){\n        var _process_env_RPC_URL;\n        this.solanaTracker = new _solanaTrackerService__WEBPACK_IMPORTED_MODULE_2__.SolanaTrackerService();\n        this.cache = new (node_cache__WEBPACK_IMPORTED_MODULE_1___default())({\n            stdTTL: 300\n        }); // 5 minutes cache\n        const rpcUrl = (((_process_env_RPC_URL = process.env.RPC_URL) === null || _process_env_RPC_URL === void 0 ? void 0 : _process_env_RPC_URL.trim()) || 'https://api.mainnet-beta.solana.com').replace(/\\/$/, '');\n        this.connection = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(rpcUrl);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90cmFkaW5nU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBd0Q7QUFDckI7QUFDb0Q7QUFpQ2hGLE1BQU1HO0lBWVQsTUFBTUMsMkJBQTBEO1FBQzVELE1BQU1DLGdCQUFzQyxFQUFFO1FBRTlDLElBQUk7WUFDQSwyQkFBMkI7WUFDM0IsTUFBTUMsYUFBYSxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxjQUFjO1lBRTFELHFCQUFxQjtZQUNyQixLQUFLLE1BQU1DLFNBQVNILFdBQVk7Z0JBQzVCLE1BQU1JLFlBQVksTUFBTSxJQUFJLENBQUNILGFBQWEsQ0FBQ0ksWUFBWSxDQUFDRixNQUFNRyxJQUFJO2dCQUNsRSxNQUFNQyxXQUFXLE1BQU0sSUFBSSxDQUFDQyxZQUFZLENBQUNKO2dCQUV6QyxJQUFJLENBQUNHLFNBQVNFLE9BQU8sRUFBRTt3QkFPSkMsYUFDSUEsaUJBQ0FBLGlCQUVLTjtvQkFWeEIsTUFBTU0sT0FBT04sVUFBVU8sS0FBSyxDQUFDLEVBQUU7b0JBQy9CWixjQUFjYSxJQUFJLENBQUM7d0JBQ2ZULE9BQU87NEJBQ0hVLFNBQVNWLE1BQU1HLElBQUk7NEJBQ25CUSxNQUFNWCxNQUFNVyxJQUFJOzRCQUNoQkMsUUFBUVosTUFBTVksTUFBTTs0QkFDcEJDLE9BQU9OLENBQUFBLGlCQUFBQSw0QkFBQUEsY0FBQUEsS0FBTU0sS0FBSyxjQUFYTixrQ0FBQUEsWUFBYU8sR0FBRyxLQUFJOzRCQUMzQkMsV0FBV1IsQ0FBQUEsaUJBQUFBLDRCQUFBQSxrQkFBQUEsS0FBTVEsU0FBUyxjQUFmUixzQ0FBQUEsZ0JBQWlCTyxHQUFHLEtBQUk7NEJBQ25DRSxXQUFXVCxDQUFBQSxpQkFBQUEsNEJBQUFBLGtCQUFBQSxLQUFNUyxTQUFTLGNBQWZULHNDQUFBQSxnQkFBaUJPLEdBQUcsS0FBSTs0QkFDbkNHLFdBQVc7NEJBQ1hDLGdCQUFnQmpCLEVBQUFBLHdCQUFBQSxVQUFVa0Is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SUFBSSxDQUFDbEQsYUFBYSxDQUFDOEQsV0FBVyxDQUFDWjthQUNsQztZQUVELE9BQU87Z0JBQ0gvQztnQkFDQStCO2dCQUNBeUI7Z0JBQ0FILGFBQWE3QixLQUFLQyxHQUFHO1lBQ3pCO1FBQ0osRUFBRSxPQUFPSSxPQUFPO1lBQ1pDLFFBQVFELEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE1BQU1BO1FBQ1Y7SUFDSjtJQWhMQStCLGFBQWM7WUFHTUM7UUFGaEIsSUFBSSxDQUFDaEUsYUFBYSxHQUFHLElBQUlMLHVFQUFvQkE7UUFDN0MsSUFBSSxDQUFDeUQsS0FBSyxHQUFHLElBQUkxRCxtREFBU0EsQ0FBQztZQUFFdUUsUUFBUTtRQUFJLElBQUksa0JBQWtCO1FBQy9ELE1BQU1DLFNBQVMsQ0FBQ0YsRUFBQUEsdUJBQUFBLE9BQU9BLENBQUNHLEdBQUcsQ0FBQ0MsT0FBTyxjQUFuQkosMkNBQUFBLHFCQUFxQkssSUFBSSxPQUFNLHFDQUFvQyxFQUFHQyxPQUFPLENBQUMsT0FBTztRQUNyRyxJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJOUUsdURBQVVBLENBQUN5RTtJQUNyQztBQTRLSiIsInNvdXJjZXMiOlsiL1VzZXJzLzhiaXQvRGVza3RvcC9lbGl6YS90cmFkaW5nL3NyYy9zZXJ2aWNlcy90cmFkaW5nU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uLCBQdWJsaWNLZXkgfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IE5vZGVDYWNoZSBmcm9tICdub2RlLWNhY2hlJztcbmltcG9ydCB7IFNvbGFuYVRyYWNrZXJTZXJ2aWNlLCBUb2tlbkluZm8sIFRva2VuSG9sZGVycyB9IGZyb20gJy4vc29sYW5hVHJhY2tlclNlcnZpY2UnO1xuXG5pbnRlcmZhY2UgVHJhZGluZ09wcG9ydHVuaXR5IHtcbiAgICB0b2tlbjoge1xuICAgICAgICBhZGRyZXNzOiBzdHJpbmc7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgc3ltYm9sOiBzdHJpbmc7XG4gICAgICAgIHByaWNlOiBudW1iZXI7XG4gICAgICAgIG1hcmtldENhcDogbnVtYmVyO1xuICAgICAgICBsaXF1aWRpdHk6IG51bWJlcjtcbiAgICAgICAgdm9sdW1lMjRoOiBudW1iZXI7XG4gICAgICAgIHByaWNlQ2hhbmdlMjRoOiBudW1iZXI7XG4gICAgfTtcbiAgICBjb25maWRlbmNlOiBudW1iZXI7XG4gICAgc2lnbmFsczogc3RyaW5nW107XG4gICAgcmlza0xldmVsOiAnTE9XJyB8ICdNRURJVU0nIHwgJ0hJR0gnO1xuICAgIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5BbmFseXNpcyB7XG4gICAgaXNSaXNreTogYm9vbGVhbjtcbiAgICBjb25maWRlbmNlOiBudW1iZXI7XG4gICAgc2lnbmFsczogc3RyaW5nW107XG4gICAgcmlza0xldmVsOiAnTE9XJyB8ICdNRURJVU0nIHwgJ0hJR0gnO1xufVxuXG5pbnRlcmZhY2UgVG9rZW5NZXRyaWNzIHtcbiAgICB0b2tlbkluZm86IFRva2VuSW5mbztcbiAgICBob2xkZXJzOiBUb2tlbkhvbGRlcnM7XG4gICAgYXRoOiB7IGhpZ2hlc3RfcHJpY2U6IG51bWJlciB9O1xuICAgIGxhc3RVcGRhdGVkOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBUcmFkaW5nU2VydmljZSB7XG4gICAgcHJpdmF0ZSBzb2xhbmFUcmFja2VyOiBTb2xhbmFUcmFja2VyU2VydmljZTtcbiAgICBwcml2YXRlIGNhY2hlOiBOb2RlQ2FjaGU7XG4gICAgcHJpdmF0ZSBjb25uZWN0aW9uOiBDb25uZWN0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc29sYW5hVHJhY2tlciA9IG5ldyBTb2xhbmFUcmFja2VyU2VydmljZSgpO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE5vZGVDYWNoZSh7IHN0ZFRUTDogMzAwIH0pOyAvLyA1IG1pbnV0ZXMgY2FjaGVcbiAgICAgICAgY29uc3QgcnBjVXJsID0gKHByb2Nlc3MuZW52LlJQQ19VUkw/LnRyaW0oKSB8fCAnaHR0cHM6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20nKS5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihycGNVcmwpO1xuICAgIH1cblxuICAgIGFzeW5jIGZpbmRUcmFkaW5nT3Bwb3J0dW5pdGllcygpOiBQcm9taXNlPFRyYWRpbmdPcHBvcnR1bml0eVtdPiB7XG4gICAgICAgIGNvbnN0IG9wcG9ydHVuaXRpZXM6IFRyYWRpbmdPcHBvcnR1bml0eVtdID0gW107XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCB0cmVuZGluZyBtZW1lIHRva2Vuc1xuICAgICAgICAgICAgY29uc3QgbWVtZVRva2VucyA9IGF3YWl0IHRoaXMuc29sYW5hVHJhY2tlci5maW5kTWVtZVRva2VucygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBbmFseXplIGVhY2ggdG9rZW5cbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgbWVtZVRva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSW5mbyA9IGF3YWl0IHRoaXMuc29sYW5hVHJhY2tlci5nZXRUb2tlbkluZm8odG9rZW4ubWludCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCB0aGlzLmFuYWx5emVUb2tlbih0b2tlbkluZm8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFhbmFseXNpcy5pc1Jpc2t5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvb2wgPSB0b2tlbkluZm8ucG9vbHNbMF07XG4gICAgICAgICAgICAgICAgICAgIG9wcG9ydHVuaXRpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuLm1pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9rZW4ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2w6IHRva2VuLnN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcG9vbD8ucHJpY2U/LnVzZCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldENhcDogcG9vbD8ubWFya2V0Q2FwPy51c2QgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXF1aWRpdHk6IHBvb2w/LmxpcXVpZGl0eT8udXNkIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lMjRoOiAwLCAvLyBOZWVkIHRvIGNhbGN1bGF0ZSBmcm9tIHRyYWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlQ2hhbmdlMjRoOiB0b2tlbkluZm8uZXZlbnRzWycyNGgnXT8ucHJpY2VDaGFuZ2VQZXJjZW50YWdlIHx8IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWRlbmNlOiBhbmFseXNpcy5jb25maWRlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsczogYW5hbHlzaXMuc2lnbmFscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpc2tMZXZlbDogYW5hbHlzaXMucmlza0xldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU29ydCBvcHBvcnR1bml0aWVzIGJ5IGNvbmZpZGVuY2VcbiAgICAgICAgICAgIHJldHVybiBvcHBvcnR1bml0aWVzLnNvcnQoKGEsIGIpID0+IGIuY29uZmlkZW5jZSAtIGEuY29uZmlkZW5jZSk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZpbmRpbmcgdHJhZGluZyBvcHBvcnR1bml0aWVzOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgYW5hbHl6ZVRva2VuKHRva2VuSW5mbzogVG9rZW5JbmZvKTogUHJvbWlzZTxUb2tlbkFuYWx5c2lzPiB7XG4gICAgICAgIGNvbnN0IHNpZ25hbHM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGxldCBjb25maWRlbmNlU2NvcmUgPSAwO1xuICAgICAgICBsZXQgaXNSaXNreSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENoZWNrIHRva2VuIGFnZVxuICAgICAgICBjb25zdCBwb29sID0gdG9rZW5JbmZvLnBvb2xzWzBdO1xuICAgICAgICBpZiAoIXBvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlzUmlza3k6IHRydWUsIGNvbmZpZGVuY2U6IDAsIHNpZ25hbHM6IFsnTm8gbGlxdWlkaXR5IHBvb2wgZm91bmQnXSwgcmlza0xldmVsOiAnSElHSCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuYWx5emUgbGlxdWlkaXR5XG4gICAgICAgIGNvbnN0IGxpcXVpZGl0eVVTRCA9IHBvb2wubGlxdWlkaXR5Py51c2QgfHwgMDtcbiAgICAgICAgaWYgKGxpcXVpZGl0eVVTRCA8IDEwMDAwKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ0xvdyBsaXF1aWRpdHknKTtcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZSAtPSAyMDtcbiAgICAgICAgfSBlbHNlIGlmIChsaXF1aWRpdHlVU0QgPiAxMDAwMDApIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnU3Ryb25nIGxpcXVpZGl0eScpO1xuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlICs9IDIwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgTFAgdG9rZW4gYnVyblxuICAgICAgICBpZiAocG9vbC5scEJ1cm4gPT09IDEwMCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCcxMDAlIExQIHRva2VucyBidXJuZWQnKTtcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZSArPSAxNTtcbiAgICAgICAgfSBlbHNlIGlmIChwb29sLmxwQnVybiA8IDUwKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ0xvdyBMUCB0b2tlbiBidXJuJyk7XG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmUgLT0gMTU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbmFseXplIHByaWNlIG1vdmVtZW50XG4gICAgICAgIGNvbnN0IHByaWNlQ2hhbmdlMjRoID0gdG9rZW5JbmZvLmV2ZW50c1snMjRoJ10/LnByaWNlQ2hhbmdlUGVyY2VudGFnZSB8fCAwO1xuICAgICAgICBpZiAoTWF0aC5hYnMocHJpY2VDaGFuZ2UyNGgpID4gNTApIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnSGlnaCB2b2xhdGlsaXR5Jyk7XG4gICAgICAgICAgICBjb25maWRlbmNlU2NvcmUgLT0gMTA7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpY2VDaGFuZ2UyNGggPiAxMCkge1xuICAgICAgICAgICAgc2lnbmFscy5wdXNoKCdQb3NpdGl2ZSBtb21lbnR1bScpO1xuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlICs9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaG9sZGVyIGRpc3RyaWJ1dGlvblxuICAgICAgICBjb25zdCBob2xkZXJzID0gYXdhaXQgdGhpcy5zb2xhbmFUcmFja2VyLmdldFRva2VuSG9sZGVycyh0b2tlbkluZm8udG9rZW4ubWludCk7XG4gICAgICAgIGNvbnN0IHRvcEhvbGRlclBlcmNlbnRhZ2UgPSBob2xkZXJzLmFjY291bnRzWzBdPy5wZXJjZW50YWdlIHx8IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAodG9wSG9sZGVyUGVyY2VudGFnZSA+IDUwKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ0NvbmNlbnRyYXRlZCBob2xkaW5ncycpO1xuICAgICAgICAgICAgY29uZmlkZW5jZVNjb3JlIC09IDI1O1xuICAgICAgICAgICAgaXNSaXNreSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wSG9sZGVyUGVyY2VudGFnZSA8IDEwKSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ1dlbGwtZGlzdHJpYnV0ZWQgaG9sZGluZ3MnKTtcbiAgICAgICAgICAgIGNvbmZpZGVuY2VTY29yZSArPSAxNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHNlY3VyaXR5IHJpc2tzXG4gICAgICAgIGlmICh0b2tlbkluZm8ucmlzay5ydWdnZWQpIHtcbiAgICAgICAgICAgIHNpZ25hbHMucHVzaCgnUnVnIHB1bGwgcmlzayBkZXRlY3RlZCcpO1xuICAgICAgICAgICAgaXNSaXNreSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW5JbmZvLnJpc2suc2NvcmUgPiA1KSB7XG4gICAgICAgICAgICBzaWduYWxzLnB1c2goJ0hpZ2ggcmlzayBzY29yZScpO1xuICAgICAgICAgICAgaXNSaXNreSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgcmlzayBsZXZlbFxuICAgICAgICBsZXQgcmlza0xldmVsOiAnTE9XJyB8ICdNRURJVU0nIHwgJ0hJR0gnO1xuICAgICAgICBpZiAoaXNSaXNreSB8fCBjb25maWRlbmNlU2NvcmUgPCAwKSB7XG4gICAgICAgICAgICByaXNrTGV2ZWwgPSAnSElHSCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlkZW5jZVNjb3JlID4gNTApIHtcbiAgICAgICAgICAgIHJpc2tMZXZlbCA9ICdMT1cnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlza0xldmVsID0gJ01FRElVTSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3JtYWxpemUgY29uZmlkZW5jZSBzY29yZSBiZXR3ZWVuIDAgYW5kIDEwMFxuICAgICAgICBjb25maWRlbmNlU2NvcmUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIGNvbmZpZGVuY2VTY29yZSArIDUwKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzUmlza3ksXG4gICAgICAgICAgICBjb25maWRlbmNlOiBjb25maWRlbmNlU2NvcmUsXG4gICAgICAgICAgICBzaWduYWxzLFxuICAgICAgICAgICAgcmlza0xldmVsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYXN5bmMgbW9uaXRvclRva2VuKHRva2VuQWRkcmVzczogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYG1vbml0b3JfJHt0b2tlbkFkZHJlc3N9YDtcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkluZm8gPSBhd2FpdCB0aGlzLnNvbGFuYVRyYWNrZXIuZ2V0VG9rZW5JbmZvKHRva2VuQWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBhbmFseXNpcyA9IGF3YWl0IHRoaXMuYW5hbHl6ZVRva2VuKHRva2VuSW5mbyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG1vbml0b3JpbmdEYXRhID0ge1xuICAgICAgICAgICAgICAgIC4uLnRva2VuSW5mbyxcbiAgICAgICAgICAgICAgICBhbmFseXNpcyxcbiAgICAgICAgICAgICAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoY2FjaGVLZXksIG1vbml0b3JpbmdEYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBtb25pdG9yaW5nRGF0YTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1vbml0b3JpbmcgdG9rZW46JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBnZXRUb2tlbk1ldHJpY3ModG9rZW5BZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPFRva2VuTWV0cmljcz4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3Rva2VuSW5mbywgaG9sZGVycywgYXRoXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLnNvbGFuYVRyYWNrZXIuZ2V0VG9rZW5JbmZvKHRva2VuQWRkcmVzcyksXG4gICAgICAgICAgICAgICAgdGhpcy5zb2xhbmFUcmFja2VyLmdldFRva2VuSG9sZGVycyh0b2tlbkFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIHRoaXMuc29sYW5hVHJhY2tlci5nZXRUb2tlbkFUSCh0b2tlbkFkZHJlc3MpXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b2tlbkluZm8sXG4gICAgICAgICAgICAgICAgaG9sZGVycyxcbiAgICAgICAgICAgICAgICBhdGgsXG4gICAgICAgICAgICAgICAgbGFzdFVwZGF0ZWQ6IERhdGUubm93KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0b2tlbiBtZXRyaWNzOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIkNvbm5lY3Rpb24iLCJOb2RlQ2FjaGUiLCJTb2xhbmFUcmFja2VyU2VydmljZSIsIlRyYWRpbmdTZXJ2aWNlIiwiZmluZFRyYWRpbmdPcHBvcnR1bml0aWVzIiwib3Bwb3J0dW5pdGllcyIsIm1lbWVUb2tlbnMiLCJzb2xhbmFUcmFja2VyIiwiZmluZE1lbWVUb2tlbnMiLCJ0b2tlbiIsInRva2VuSW5mbyIsImdldFRva2VuSW5mbyIsIm1pbnQiLCJhbmFseXNpcyIsImFuYWx5emVUb2tlbiIsImlzUmlza3kiLCJwb29sIiwicG9vbHMiLCJwdXNoIiwiYWRkcmVzcyIsIm5hbWUiLCJzeW1ib2wiLCJwcmljZSIsInVzZCIsIm1hcmtldENhcCIsImxpcXVpZGl0eSIsInZvbHVtZTI0aCIsInByaWNlQ2hhbmdlMjRoIiwiZXZlbnRzIiwicHJpY2VDaGFuZ2VQZXJjZW50YWdlIiwiY29uZmlkZW5jZSIsInNpZ25hbHMiLCJyaXNrTGV2ZWwiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93Iiwic29ydCIsImEiLCJiIiwiZXJyb3IiLCJjb25zb2xlIiwiaG9sZGVycyIsImNvbmZpZGVuY2VTY29yZSIsImxpcXVpZGl0eVVTRCIsImxwQnVybiIsIk1hdGgiLCJhYnMiLCJnZXRUb2tlbkhvbGRlcnMiLCJ0b3BIb2xkZXJQZXJjZW50YWdlIiwiYWNjb3VudHMiLCJwZXJjZW50YWdlIiwicmlzayIsInJ1Z2dlZCIsInNjb3JlIiwibWF4IiwibWluIiwibW9uaXRvclRva2VuIiwidG9rZW5BZGRyZXNzIiwiY2FjaGVLZXkiLCJjYWNoZSIsImhhcyIsImdldCIsIm1vbml0b3JpbmdEYXRhIiwibGFzdFVwZGF0ZWQiLCJzZXQiLCJnZXRUb2tlbk1ldHJpY3MiLCJhdGgiLCJQcm9taXNlIiwiYWxsIiwiZ2V0VG9rZW5BVEgiLCJjb25zdHJ1Y3RvciIsInByb2Nlc3MiLCJzdGRUVEwiLCJycGNVcmwiLCJlbnYiLCJSUENfVVJMIiwidHJpbSIsInJlcGxhY2UiLCJjb25uZWN0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/tradingService.ts\n"));

/***/ })

});